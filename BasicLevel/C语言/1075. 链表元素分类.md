## 1075. 链表元素分类
给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而\[0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。

**输入格式：**
每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N ($≤10^5$)；以及正整数K ($≤10^3$)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。

接下来有 N 行，每行格式为：
`Address Data Next`
其中 Address 是结点地址；Data 是该结点保存的数据，为\[$−10^5$, $10^5$]区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。

**输出格式：**
对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。

**输入样例：**
>00100 9 10  
23333 10 27777  
00000 0 99999  
00100 18 12309  
68237 -6 23333  
33218 -4 00000  
48652 -2 -1  
99999 5 68237  
27777 11 48652  
12309 7 33218  

**输出样例：**
>33218 -4 68237  
68237 -6 48652  
48652 -2 12309  
12309 7 00000  
00000 0 99999  
99999 5 23333  
23333 10 00100  
00100 18 27777  
27777 11 -1  

---
- （根据1025出的题）待优化
- **通过数组下标表示节点地址**
- **存在无效节点**

```c
#include <stdio.h>

typedef struct {
	int addr;
	int data;
	int next;	
} Node;
int main() {
    int firstAddr, N, K, minus_cnt = 0, cnt_K = 0;//第一个节点的地址，节点总数，正整数K ,负数的数量 
	scanf("%d %d %d", &firstAddr, &N, &K); 
    Node nodes[100001];//下标为节点地址 
    int addr; 
    for (int i = 0; i < N; i++) {
    	scanf("%d ", &addr);
    	scanf("%d %d", &nodes[addr].data, &nodes[addr].next);
    	if (nodes[addr].data < 0) {//统计负数数量 
    		minus_cnt++;
		} else if (nodes[addr].data >= 0 && nodes[addr].data <= K) {//统计 [0, K] 区间内的元素数量 
			cnt_K++;
		}
	}
	Node newNodes[N];//节点总数 
	addr = firstAddr;
	int i= 0;
	while (addr != -1 && minus_cnt != 0) {//遍历链表
		if (nodes[addr].data < 0) {//如果是负数 
			newNodes[i].addr = addr;
			newNodes[i].data = nodes[addr].data;
			i++;
			minus_cnt--;
		} 
		addr = nodes[addr].next;
	}
	addr = firstAddr;
	while (addr != -1 && cnt_K != 0) {//遍历链表
		if (nodes[addr].data >= 0 && nodes[addr].data <= K) {
			newNodes[i].addr = addr;
			newNodes[i].data = nodes[addr].data;
			i++;
			cnt_K--; 
		} 
		addr = nodes[addr].next;
	}
	addr = firstAddr;
	while (addr != -1 && i != N) {//遍历链表
		if (nodes[addr].data > K) {
			newNodes[i].addr = addr;
			newNodes[i].data = nodes[addr].data;
			i++;
		} 
		addr = nodes[addr].next;
	}
	newNodes[i].addr = -1;
	for (int j = 0; j < N; j++) {
		printf("%05d %d ", newNodes[j].addr, newNodes[j].data);
		if (newNodes[j+1].addr != -1) {
			printf("%05d\n", newNodes[j+1].addr);
		} else {
			printf("-1\n");
			break;
		}
	}
    return 0;
}
```